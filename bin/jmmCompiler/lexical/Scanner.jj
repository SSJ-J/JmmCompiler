/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Scanner.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options {
             
  KEEP_LINE_COLUMN = true;
  //STATIC=false;
}
PARSER_BEGIN(Scanner)package jmmCompiler.lexical;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;

public class Scanner/*@bgen(jjtree)*/implements ScannerTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTScannerState jjtree = new JJTScannerState();

/*@egen*/
  
  /** Main entry point. */
  public static Node parse(InputStream input) {
    if(jj_initialized_once)
      Scanner.ReInit(input);
    else
      new Scanner(input);

    ASTStart n = null;
    try {
      n = Scanner.Start();
    } catch (ParseException e) {
      System.out.println(e.getMessage());
    } catch (Error e) {        System.out.println(e.getMessage());
    }
    return n;
  }
  
  public static String scan(InputStream input) {
    if(jj_initialized_once)
      Scanner.ReInit(input);
    else
      new Scanner(input);
            
    Token t = null;
    String attribute = "";
    String result = "";
    while (true) {      
      try {
        t = ScannerTokenManager.getNextToken();
        if(t.kind == ScannerConstants.EOF) {          result += ("\n");
          return result;
        }      
        attribute = ScannerConstants.tokenImage[t.kind] + " ";
   
        /* deal with token without keywords and operators */
        if(attribute.charAt(0) == '<') {
          attribute = attribute.substring(1, attribute.length()-2);
          attribute = String.format("<%s, %s> ", attribute, t.image); 
        }
        result += attribute;
      }
      catch (Exception e) {
        result += "\n"+e.getMessage();
        break;
      }
      catch (Error e) {
        result += "\n"+e.getMessage();
        break;
      }
    }
    return result;
    }
}PARSER_END(Scanner)SKIP :{    " "  | "\r"  | "\t"  | "\n"
    /* COMMENTS */
  | <"//"(~["\r", "\n"])*["\r", "\n"]>
  | < "/*"(~["*"])* "*" ("*" | ~["*", "/"](~["*"])*"*")* "/">}

TOKEN : /* LITERAL */
{
    < INTEGER_LITERAL: <DECIMAL_NUMERAL> >
  | < FLOATING_POINT_LITERAL: <DIGITS>"."<DIGITS> >
  | < BOOLEAN_LITERAL: "true"|"false"  >
  | < CHARACTER_LITERAL: "'"(<CHARACTER>|"\"")"'" >
  | < STRING_LITERAL: "\""(< CHARACTER> | "'")*"\"" >
  | < NULL_LITERAL: "null" >
  | < #DECIMAL_NUMERAL: "0" | <NON_ZERO_DIGIT> (<DIGITS>)? > 
  | < #DIGITS: (<DIGIT>)+ > 
  | < #DIGIT: "0" | < NON_ZERO_DIGIT> > 
  | < #NON_ZERO_DIGIT: ["1"-"9"] >
  | < #LETTER: ["A"-"Z", "a"-"z"]>
  | < #CHARACTER : <LETTER> | <DIGIT>
          | ["~","`","!","@","#","$",
             "%","^","&","*","(",")",
             "_","-","+","=","{","[",
             "}","]","|",":",";",
             "<",",",">",".","?",
             "/"," ","\n","\r","\t"
          ] > // no ', \, "
}
TOKEN : /* KEYWORDS */{    < BOOLEAN : "boolean">
  | <BREAK : "break">
  | <CHAR : "char">
  | <CLASS : "class">
  | <CONTINUE : "continue">
  | <DO : "do">
  | <DOUBLE : "double">
  | <ELSE : "else">
  | <EXTENDS : "extends">
  | <FOR : "for">
  | <FOREACH : "foreach">
  | <IF : "if">
  | <INSTANCEOF : "instanceof">
  | <INT : "int">
  | <NEW : "new">
  | <PRIVATE : "private">
  | <PROTECTED : "protected">
  | <PUBLIC : "public">
  | <RETURN : "return">
  | <STATIC : "static">
  | <SUPER : "super">
  | <THIS : "this">
  | <VOID : "void">
  | <WHILE : "while">
}
TOKEN : /* OPERATORS */{    < PLUS : "+" >  | < MINUS : "-" >  | < MULTIPLY : "*" >  | < DIVIDE : "/" >
  | < MOD : "%">
  | < UNDERSCORE : "_" >
  | < COMMA : "," >
  | < SEMICOLON:";" >
  | < COLON : ":">
  | < LP : "(" >
  | < RP : ")" >
  | < LSB : "[" >
  | < RSB : "]" >
  | < LB : "{" >
  | < RB : "}" >
  | < QUOTE : "\"" >
  | < ASSIGN : "=">
  | < EQUAL : "==">
  | < LESS : "<">
  | < BIGGER : ">">
  | < LESS_OR_E : "<=">
  | < BIGGER_OR_E : " >=">
  | < AND : "&&">
  | < OR : "||">
  | < NOT : "!">
  | < NE : "!=">
  | < DOT : ".">}
TOKEN :{   < IDENTIFIER: <LETTER>(<LETTER> | <DIGIT> | "_")* >}

/** Program Start. */
ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    (TypeDeclaration())* <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** Declarations */
void TypeDeclaration()       : {}
{    ClassDeclaration()
  | < SEMICOLON >
}

void ClassDeclaration() : {/*@bgen(jjtree) ClassDeclaration */
  ASTClassDeclaration jjtn000 = new ASTClassDeclaration(JJTCLASSDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDeclaration */
    try {
/*@egen*/
    <CLASS>Name()[<EXTENDS>Name()]<LB>(ClassBodyDecl())*<RB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassBodyDecl(): {/*@bgen(jjtree) ClassBodyDecl */
  ASTClassBodyDecl jjtn000 = new ASTClassBodyDecl(JJTCLASSBODYDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassBodyDecl */
    try {
/*@egen*/
    LOOKAHEAD(Modifier()[<STATIC>]Name())
    FieldDecl()
  |
    LOOKAHEAD(Modifier()[<STATIC>]ResultType()Name()<LP>)
    MethodDecl()
  |
    LOOKAHEAD(Modifier()Name()<LP>)
    ConstructorDecl()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void FieldDecl() : {/*@bgen(jjtree) FieldDecl */
  ASTFieldDecl jjtn000 = new ASTFieldDecl(JJTFIELDDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FieldDecl */
    try {
/*@egen*/
    /* Not support array initialization */
    Modifier()[ModifierStatic()]Type()VarDeclId()[<ASSIGN>Expression()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclId()       : {}
{
    Name()[<LSB><RSB>]
}

void MethodDecl() : {/*@bgen(jjtree) MethodDecl */
  ASTMethodDecl jjtn000 = new ASTMethodDecl(JJTMETHODDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDecl */
    try {
/*@egen*/
    Modifier()[ModifierStatic()]ResultType()MethodDeclarator()Block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodDeclarator() : {/*@bgen(jjtree) MethodDeclarator */
  ASTMethodDeclarator jjtn000 = new ASTMethodDeclarator(JJTMETHODDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDeclarator */
    try {
/*@egen*/
    Name()FormalParameters()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FormalParameters() :
{/*@bgen(jjtree) FormalParameters */
  ASTFormalParameters jjtn000 = new ASTFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalParameters */
    try {
/*@egen*/
    <LP>[ FormalParameter() (<COMMA>FormalParameter())* ]<RP>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FormalParameter() :
{/*@bgen(jjtree) FormalParameter */
  ASTFormalParameter jjtn000 = new ASTFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FormalParameter */
    try {
/*@egen*/
    Type()VarDeclId()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ConstructorDecl() : {/*@bgen(jjtree) ConstructorDecl */
  ASTConstructorDecl jjtn000 = new ASTConstructorDecl(JJTCONSTRUCTORDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ConstructorDecl */
    try {
/*@egen*/
    Modifier()Name()FormalParameters()
    <LB>
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
    (BlockStatement())*
    <RB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExplicitConstructorInvocation() :
{/*@bgen(jjtree) ExplicitConstructorInvocation */
  ASTExplicitConstructorInvocation jjtn000 = new ASTExplicitConstructorInvocation(JJTEXPLICITCONSTRUCTORINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExplicitConstructorInvocation */
    try {
/*@egen*/
    (<THIS>|<SUPER>)Arguments()<SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** Types, Name and Modifiers */
void Type()       : {}
{
  LOOKAHEAD((PrimitiveType()|Name())<LSB>)/*@bgen(jjtree) #ArrayType(true) */
  {
    ASTArrayType jjtn001 = new ASTArrayType(JJTARRAYTYPE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    (PrimitiveType()|Name())<LSB><RSB>
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/              
  |
    (PrimitiveType()|Name())
}

void PrimitiveType() : {/*@bgen(jjtree) PrimitiveType */
  ASTPrimitiveType jjtn000 = new ASTPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrimitiveType */
  try {
/*@egen*/
  <INT> | <DOUBLE> | <CHAR> | <BOOLEAN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ResultType() :
{/*@bgen(jjtree) ResultType */
 ASTResultType jjtn000 = new ASTResultType(JJTRESULTTYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ResultType */
    try {
/*@egen*/
    t = < VOID >/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/   {jjtn000.setName(t.image);}
  | Type()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}
Token Name() :
{/*@bgen(jjtree) Name */
 ASTName jjtn000 = new ASTName(JJTNAME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t=null;}
{/*@bgen(jjtree) Name */
    try {
/*@egen*/    t = < IDENTIFIER >/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.setName(t.image);
     return t; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ModifierStatic() :
{/*@bgen(jjtree) ModifierStatic */
 ASTModifierStatic jjtn000 = new ASTModifierStatic(JJTMODIFIERSTATIC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t=null;}
{/*@bgen(jjtree) ModifierStatic */
    try {
/*@egen*/    t = <STATIC>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Modifier() : 
{/*@bgen(jjtree) Modifier */
 ASTModifier jjtn000 = new ASTModifier(JJTMODIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t=null;}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/    t = < PUBLIC >/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setName(t.image);}
  | t = < PRIVATE >/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.setName(t.image);}
  | t = < PROTECTED >/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.setName(t.image);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** Blocks and Commands */
void Statement()       : {}
{
    Block()
  | EmptyStatement()
  | ExpressionStatement()
  | IfStatement()
  | WhileStatement()
  | DoStatement()
  | ForStatement()
  | ForeachStatement()
  | BreakStatement()
  | ContinueStatement()
  | ReturnStatement()
}

void Block() : {/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
    try {
/*@egen*/
    <LB> (BlockStatement())* <RB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BlockStatement()       : {}
{
    LOOKAHEAD(Type()Name())/*@bgen(jjtree) #InitializerExp(> 1) */
  {
    ASTInitializerExp jjtn001 = new ASTInitializerExp(JJTINITIALIZEREXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    LocalVarDecl()[<ASSIGN>Expression()]<SEMICOLON>
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/                     
  |
    Statement()
}

void LocalVarDecl() : {/*@bgen(jjtree) LocalVarDecl */
  ASTLocalVarDecl jjtn000 = new ASTLocalVarDecl(JJTLOCALVARDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LocalVarDecl */
    try {
/*@egen*/
    Type()VarDeclId()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EmptyStatement() :
{/*@bgen(jjtree) EmptyStatement */
  ASTEmptyStatement jjtn000 = new ASTEmptyStatement(JJTEMPTYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) EmptyStatement */
    try {
/*@egen*/
    <SEMICOLON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ExpressionStatement()      : {}
{      StatementExpression()<SEMICOLON>
}

void StatementExpression()      : {}
{
    PrimaryExpression()[<ASSIGN>Expression()]
}

void IfStatement() : {/*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{/*@bgen(jjtree) IfStatement */
    try {
/*@egen*/
    <IF><LP>Expression()<RP>Statement()
    [ LOOKAHEAD(1)
      <ELSE> Statement()
    ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void WhileStatement() : {/*@bgen(jjtree) WhileStatement */
  ASTWhileStatement jjtn000 = new ASTWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
    try {
/*@egen*/
    <WHILE><LP>Expression()<RP>Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DoStatement() : {/*@bgen(jjtree) DoStatement */
  ASTDoStatement jjtn000 = new ASTDoStatement(JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoStatement */
    try {
/*@egen*/
    <DO>Statement()<WHILE><LP>Expression()<RP><SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ForStatement() : {/*@bgen(jjtree) ForStatement */
  ASTForStatement jjtn000 = new ASTForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForStatement */
    try {
/*@egen*/
    <FOR><LP>[ForInit()]<SEMICOLON>[Expression()]<SEMICOLON>[ForUpdate()]<RP>
    Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ForInit() :
{/*@bgen(jjtree) ForInit */
  ASTForInit jjtn000 = new ASTForInit(JJTFORINIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForInit */
    try {
/*@egen*/
    LOOKAHEAD(Type()Name())
    LocalVarDecl()<ASSIGN>Expression()
  |
    StatementExpressionList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ForUpdate() : {/*@bgen(jjtree) ForUpdate */
  ASTForUpdate jjtn000 = new ASTForUpdate(JJTFORUPDATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForUpdate */
    try {
/*@egen*/
    StatementExpressionList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StatementExpressionList() : {/*@bgen(jjtree) StatementExpressionList */
  ASTStatementExpressionList jjtn000 = new ASTStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StatementExpressionList */
    try {
/*@egen*/
    StatementExpression() (<COMMA>StatementExpression())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ForeachStatement() : {/*@bgen(jjtree) ForeachStatement */
  ASTForeachStatement jjtn000 = new ASTForeachStatement(JJTFOREACHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ForeachStatement */
    try {
/*@egen*/
    <FOREACH><LP>LocalVarDecl()<COLON>Name()<RP>
    Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BreakStatement() : {/*@bgen(jjtree) BreakStatement */
  ASTBreakStatement jjtn000 = new ASTBreakStatement(JJTBREAKSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BreakStatement */
    try {
/*@egen*/
    <BREAK><SEMICOLON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ContinueStatement() :
{/*@bgen(jjtree) ContinueStatement */
  ASTContinueStatement jjtn000 = new ASTContinueStatement(JJTCONTINUESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ContinueStatement */
    try {
/*@egen*/
    <CONTINUE><SEMICOLON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ReturnStatement() :
{/*@bgen(jjtree) ReturnStatement */
  ASTReturnStatement jjtn000 = new ASTReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
    try {
/*@egen*/
    <RETURN><SEMICOLON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** Expressions */
void Expression()      : {}
{/*@bgen(jjtree) #AssignExp(> 1) */
  {
    ASTAssignExp jjtn001 = new ASTAssignExp(JJTASSIGNEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    OrExp()[<ASSIGN>Expression()]
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/                
}

void OrExp()        : {}
{/*@bgen(jjtree) #OrExp(> 1) */
  {
    ASTOrExp jjtn001 = new ASTOrExp(JJTOREXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    AndExp() (<OR>AndExp())*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/           
}

void AndExp()       : {}
{/*@bgen(jjtree) #AndExp(> 1) */
  {
    ASTAndExp jjtn001 = new ASTAndExp(JJTANDEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    EqualityExp() (<AND>EqualityExp())*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/            
}

void EqualityExp()       : {}
{/*@bgen(jjtree) #EqualityExp(> 1) */
  {
    ASTEqualityExp jjtn001 = new ASTEqualityExp(JJTEQUALITYEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    InstanceOfExp() ((<EQUAL>|<NE>) InstanceOfExp())*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/                   
}

void InstanceOfExp()       : {}
{/*@bgen(jjtree) #InstanceOfExp(> 1) */
  {
    ASTInstanceOfExp jjtn001 = new ASTInstanceOfExp(JJTINSTANCEOFEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    RelationalExp() [<INSTANCEOF>Type() ]
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/                   
}

void RelationalExp()       :
{}
{/*@bgen(jjtree) #RelationalExp(> 1) */
  {
    ASTRelationalExp jjtn001 = new ASTRelationalExp(JJTRELATIONALEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    AddExp() ((<BIGGER>|<LESS>|<BIGGER_OR_E>|<LESS_OR_E>) AddExp())*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/                     
}

void AddExp()       : {}
{/*@bgen(jjtree) #AddExp(> 1) */
  {
    ASTAddExp jjtn001 = new ASTAddExp(JJTADDEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    MultiExp() ((<PLUS>|<MINUS>) MultiExp())*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/            
}

void MultiExp()       : {}
{/*@bgen(jjtree) #MultiExp(> 1) */
  {
    ASTMultiExp jjtn001 = new ASTMultiExp(JJTMULTIEXP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  (
    UnaryExpression() ((<MULTIPLY>|<DIVIDE>|<MOD>)UnaryExpression() )*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/              
}

void UnaryExpression()      : {}
{/*@bgen(jjtree) #UnaryExpression(true) */
    {
      ASTUnaryExpression jjtn001 = new ASTUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (      (<PLUS>|<MINUS>)UnaryExpression()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/                   
  |
    UnaryExpressionNotPlusMinus()
}

void UnaryExpressionNotPlusMinus()       : {}
{/*@bgen(jjtree) #NotExpression(true) */
    {
      ASTNotExpression jjtn001 = new ASTNotExpression(JJTNOTEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (
      <NOT>UnaryExpression()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/                 
  | LOOKAHEAD( CastLookahead() )
    CastExpression()
  | PrimaryExpression()
}

/* To determine lookahead only. */
void CastLookahead() : {/*@bgen(jjtree) CastLookahead */
  ASTCastLookahead jjtn000 = new ASTCastLookahead(JJTCASTLOOKAHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CastLookahead */
    try {
/*@egen*/
    LOOKAHEAD(2)
    <LP>PrimitiveType()
  |
    LOOKAHEAD(<LP>Name()<LSB>)
    <LP>Name()<LSB><RSB>    // array
  |
    /* Class Type */
    <LP>Name()<RP>( <NOT>|<LP>|<IDENTIFIER>|<THIS>|<SUPER>|<NEW>|Literal())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CastExpression() : {/*@bgen(jjtree) CastExpression */
  ASTCastExpression jjtn000 = new ASTCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CastExpression */
    try {
/*@egen*/
    LOOKAHEAD(<LP>PrimitiveType())
    <LP>Type()<RP>UnaryExpression()
  |
    <LP>Type()<RP>UnaryExpressionNotPlusMinus()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PrimaryExpression()       : {}
{/*@bgen(jjtree) #PrimaryExpression(> 1) */
  {
    ASTPrimaryExpression jjtn001 = new ASTPrimaryExpression(JJTPRIMARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
    // PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
  (  
    PrimaryPrefix() (PrimarySuffix())*
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/                       
}

void PrimaryPrefix()      : {Token tmp=null;}
{
    Literal()
  | <THIS>
  | <SUPER><DOT><IDENTIFIER>
  | <LP>Expression()<RP>
  | AllocationExpression()
  | LOOKAHEAD(ResultType()<DOT><CLASS>)     // show class
    ResultType()<DOT><CLASS>
  | Name()
}

void PrimarySuffix()      : {}
{
    LOOKAHEAD(2)
    <DOT>AllocationExpression()
  |/*@bgen(jjtree) #ArrayAccess(true) */
    {
      ASTArrayAccess jjtn001 = new ASTArrayAccess(JJTARRAYACCESS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ (<LSB>Expression()<RSB>)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/               
  | <DOT>Name()
  | Arguments()
}

void Literal() :
{/*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = new ASTLiteral(JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Literal */
    try {
/*@egen*/
    <INTEGER_LITERAL>
  | <FLOATING_POINT_LITERAL>
  | <CHARACTER_LITERAL>
  | <STRING_LITERAL>
  | <BOOLEAN_LITERAL>
  | <NULL_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Arguments() : {/*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = new ASTArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Arguments */
    try {
/*@egen*/
    <LP>[ArgumentList()]<RP>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArgumentList()       : {}
{
    Expression() (<COMMA>Expression() )*
}

void AllocationExpression() : {/*@bgen(jjtree) AllocationExpression */
  ASTAllocationExpression jjtn000 = new ASTAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AllocationExpression */
    try {
/*@egen*/
    LOOKAHEAD(2)
    <NEW>PrimitiveType() ArrayDimsAndInits()
  | <NEW>Name()Arguments()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArrayDimsAndInits() :
{/*@bgen(jjtree) ArrayDimsAndInits */
  ASTArrayDimsAndInits jjtn000 = new ASTArrayDimsAndInits(JJTARRAYDIMSANDINITS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArrayDimsAndInits */
    try {
/*@egen*/
    <LSB>Expression()<RSB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}